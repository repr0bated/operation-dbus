// Auto-generated D-Bus plugin system
// Discovers D-Bus services and creates plugins dynamically

use crate::state::plugin::{
    ApplyResult, Checkpoint, PluginCapabilities, StateAction, StateDiff, StatePlugin,
};
use anyhow::{Context, Result};
use async_trait::async_trait;
#[cfg(any(feature = "mcp", feature = "web"))]
use crate::mcp::introspection_parser;
use serde_json::Value;
use std::collections::HashMap;
use std::sync::Arc;
use zbus::{Connection, Proxy};

/// Auto-generated plugin that wraps any D-Bus service
#[cfg(feature = "mcp")]
pub struct AutoGeneratedPlugin {
    /// Plugin name (derived from service name)
    name: String,

    /// D-Bus service name (e.g., "org.freedesktop.NetworkManager")
    service_name: String,

    /// Base object path (e.g., "/org/freedesktop/NetworkManager")
    base_path: String,

    /// Parsed introspection data (interfaces, methods, properties)
    introspection: introspection_parser::IntrospectionData,

    /// Cached connection (reused for performance)
    connection: Option<Connection>,
}

#[cfg(feature = "mcp")]
impl AutoGeneratedPlugin {
    /// Create a new auto-generated plugin for a D-Bus service
    pub async fn new(service_name: String) -> Result<Self> {
        // Derive plugin name from service name
        // org.freedesktop.NetworkManager → networkmanager
        let name = Self::service_to_plugin_name(&service_name);

        // Derive base path from service name
        // org.freedesktop.NetworkManager → /org/freedesktop/NetworkManager
        let base_path = format!("/{}", service_name.replace('.', "/"));

        // Connect and introspect
        let conn = Connection::system().await?;
        let introspection = Self::introspect_service(&conn, &service_name, &base_path).await?;

        Ok(Self {
            name,
            service_name,
            base_path,
            introspection,
            connection: Some(conn),
        })
    }

    /// Convert D-Bus service name to plugin name
    /// org.freedesktop.NetworkManager → networkmanager
    fn service_to_plugin_name(service: &str) -> String {
        service
            .split('.')
            .last()
            .unwrap_or(service)
            .to_lowercase()
    }

    /// Introspect a D-Bus service and parse its schema
    async fn introspect_service(
        conn: &Connection,
        service_name: &str,
        path: &str,
    ) -> Result<introspection_parser::IntrospectionData> {
        // Create proxy for introspection
        let proxy = Proxy::new(
            conn,
            service_name,
            path,
            "org.freedesktop.DBus.Introspectable",
        )
        .await?;

        // Call Introspect() method
        let xml: String = proxy
            .call("Introspect", &())
            .await
            .context("Failed to call Introspect")?;

        // Parse XML to structured data
        Ok(introspection_parser::IntrospectionParser::parse_xml(&xml))
    }

    /// Read all properties from all interfaces
    async fn read_all_properties(&self) -> Result<Value> {
        let conn = self.connection.as_ref().context("No connection")?;
        let mut result = serde_json::Map::new();

        // For each interface in the introspection data
        for interface in &self.introspection.interfaces {
            let mut interface_props = serde_json::Map::new();

            // Create proxy for this interface
            let proxy = Proxy::new(
                conn,
                self.service_name.as_str(),
                self.base_path.as_str(),
                interface.name.as_str(),
            )
            .await?;

            // Read each property
            for prop in &interface.properties {
                if prop.access.contains("read") {
                    match self.read_property(&proxy, &prop.name).await {
                        Ok(value) => {
                            interface_props.insert(prop.name.clone(), value);
                        }
                        Err(e) => {
                            // Log error but continue with other properties
                            log::warn!("Failed to read property {}: {}", prop.name, e);
                        }
                    }
                }
            }

            result.insert(interface.name.clone(), Value::Object(interface_props));
        }

        Ok(Value::Object(result))
    }

    /// Read a single D-Bus property
    async fn read_property(&self, proxy: &Proxy<'_>, property: &str) -> Result<Value> {
        // Use Properties interface to get property value
        let value: zbus::zvariant::OwnedValue = proxy
            .get_property(property)
            .await
            .context(format!("Failed to get property {}", property))?;

        // Convert D-Bus value to JSON (simplified)
        Ok(Self::dbus_to_json(&value))
    }

    /// Convert D-Bus zvariant::Value to serde_json::Value
    fn dbus_to_json(value: &zbus::zvariant::Value) -> Value {
        // Simplified conversion - would need full type handling in production
        match value {
            zbus::zvariant::Value::Bool(b) => Value::Bool(*b),
            zbus::zvariant::Value::U8(n) => Value::Number((*n).into()),
            zbus::zvariant::Value::U16(n) => Value::Number((*n).into()),
            zbus::zvariant::Value::U32(n) => Value::Number((*n).into()),
            zbus::zvariant::Value::U64(n) => Value::Number((*n).into()),
            zbus::zvariant::Value::I16(n) => Value::Number((*n).into()),
            zbus::zvariant::Value::I32(n) => Value::Number((*n).into()),
            zbus::zvariant::Value::I64(n) => Value::Number((*n).into()),
            zbus::zvariant::Value::Str(s) => Value::String(s.to_string()),
            _ => {
                // For complex types, use debug representation
                Value::String(format!("{:?}", value))
            }
        }
    }
}

#[cfg(feature = "mcp")]
#[cfg(feature = "mcp")]
#[async_trait]
impl StatePlugin for AutoGeneratedPlugin {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        "1.0.0-auto"
    }

    fn is_available(&self) -> bool {
        // Check if D-Bus service is available
        // This is checked at creation time, so if we exist, it's available
        true
    }

    fn unavailable_reason(&self) -> String {
        format!("D-Bus service '{}' not found", self.service_name)
    }

    async fn query_current_state(&self) -> Result<Value> {
        // Read all properties from all interfaces
        self.read_all_properties().await
    }

    async fn calculate_diff(&self, current: &Value, desired: &Value) -> Result<StateDiff> {
        // Simple JSON diff for auto-generated plugins
        let actions = if current != desired {
            vec![StateAction::Modify {
                resource: self.name.clone(),
                changes: desired.clone(),
            }]
        } else {
            vec![StateAction::NoOp {
                resource: self.name.clone(),
            }]
        };

        Ok(StateDiff {
            plugin: self.name.clone(),
            actions,
            metadata: crate::state::plugin::DiffMetadata {
                timestamp: chrono::Utc::now().timestamp(),
                current_hash: format!("{:x}", md5::compute(current.to_string())),
                desired_hash: format!("{:x}", md5::compute(desired.to_string())),
            },
        })
    }

    async fn apply_state(&self, diff: &StateDiff) -> Result<ApplyResult> {
        // For auto-generated plugins, we can't safely apply changes
        // without understanding the semantics of each D-Bus method
        // So we return a placeholder for now

        Ok(ApplyResult {
            success: false,
            changes_applied: vec![],
            errors: vec![format!(
                "Auto-generated plugin '{}' is read-only. Manual plugin needed for writes.",
                self.name
            )],
            checkpoint: None,
        })
    }

    async fn verify_state(&self, desired: &Value) -> Result<bool> {
        let current = self.query_current_state().await?;
        Ok(&current == desired)
    }

    async fn create_checkpoint(&self) -> Result<Checkpoint> {
        let current = self.query_current_state().await?;

        Ok(Checkpoint {
            id: uuid::Uuid::new_v4().to_string(),
            plugin: self.name.clone(),
            timestamp: chrono::Utc::now().timestamp(),
            state_snapshot: current,
            backend_checkpoint: None,
        })
    }

    async fn rollback(&self, _checkpoint: &Checkpoint) -> Result<()> {
        Err(anyhow::anyhow!(
            "Rollback not supported for auto-generated plugins"
        ))
    }

    fn capabilities(&self) -> PluginCapabilities {
        PluginCapabilities {
            supports_rollback: false,
            supports_checkpoints: true,
            supports_verification: true,
            atomic_operations: false,
        }
    }
}

/// Discovers D-Bus services and creates auto-generated plugins
#[cfg(feature = "mcp")]
pub struct PluginDiscovery;

#[cfg(feature = "mcp")]
impl PluginDiscovery {
    /// Discover all manageable D-Bus services on the system bus
    pub async fn discover_services() -> Result<Vec<String>> {
        let conn = Connection::system().await?;

        // Get D-Bus daemon proxy
        let proxy = Proxy::new(
            &conn,
            "org.freedesktop.DBus",
            "/org/freedesktop/DBus",
            "org.freedesktop.DBus",
        )
        .await?;

        // Call ListNames to get all services
        let names: Vec<String> = proxy
            .call("ListNames", &())
            .await
            .context("Failed to list D-Bus services")?;

        // Filter to manageable services
        Ok(names
            .into_iter()
            .filter(|name| Self::is_manageable_service(name))
            .collect())
    }

    /// Check if a service should be managed by op-dbus
    fn is_manageable_service(name: &str) -> bool {
        // Include services from:
        // - org.freedesktop.* (except DBus internals)
        // - Custom services (reverse domain names)

        // Exclude:
        // - DBus internal services
        // - Session-only services
        // - Temporary services (starting with :)

        if name.starts_with(':') {
            return false; // Temporary unique names
        }

        if name == "org.freedesktop.DBus" {
            return false; // DBus daemon itself
        }

        if name.starts_with("org.freedesktop.DBus.") {
            return false; // DBus internal services
        }

        // Include well-known freedesktop services
        if name.starts_with("org.freedesktop.") {
            return true;
        }

        // Include custom services with reverse domain names
        if name.contains('.') && !name.starts_with("org.freedesktop.systemd1.") {
            return true;
        }

        false
    }

    /// Create auto-generated plugins for all discovered services
    pub async fn create_plugins() -> Result<Vec<Arc<dyn StatePlugin>>> {
        let services = Self::discover_services().await?;
        let mut plugins: Vec<Arc<dyn StatePlugin>> = Vec::new();

        log::info!("Discovered {} D-Bus services", services.len());

        for service in services {
            match AutoGeneratedPlugin::new(service.clone()).await {
                Ok(plugin) => {
                    log::info!("  ✓ Auto-generated plugin: {}", plugin.name());
                    plugins.push(Arc::new(plugin));
                }
                Err(e) => {
                    log::warn!("  ⊗ Failed to generate plugin for {}: {}", service, e);
                }
            }
        }

        Ok(plugins)
    }
}
