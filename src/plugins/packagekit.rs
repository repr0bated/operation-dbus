// src/plugins/packagekit.rs - PackageKit plugin for declarative package management
//
// This plugin reads state.json and installs packages via PackageKit D-Bus.
// It integrates the proxmox-extractor toolkit functionality into op-dbus.

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::fs;
use std::time::Duration;
use tokio::time::sleep;
use tracing::{info, warn};
use zbus::Connection;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageKitPlugin {
    #[serde(default)]
    pub repositories: Vec<Repository>,

    /// Path to manifest.json (generated by proxmox-manifest)
    pub manifest: Option<PathBuf>,

    /// Additional packages to install
    #[serde(default)]
    pub additional_packages: Vec<String>,

    /// Install individual packages (alternative to manifest)
    #[serde(default)]
    pub packages: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Repository {
    pub name: String,
    pub url: String,
    pub distribution: String,
    pub components: Vec<String>,
    pub gpg_key: String,
}

impl PackageKitPlugin {
    pub async fn apply(&self) -> Result<()> {
        info!("PackageKit plugin: Starting package installation");

        // Step 1: Configure repositories
        if !self.repositories.is_empty() {
            self.configure_repositories().await?;
        }

        // Step 2: Refresh cache
        self.refresh_cache().await?;

        // Step 3: Install from manifest (if provided)
        if let Some(ref manifest_path) = self.manifest {
            self.install_from_manifest(manifest_path).await?;
        }

        // Step 4: Install individual packages
        if !self.packages.is_empty() {
            self.install_packages(&self.packages).await?;
        }

        // Step 5: Install additional packages
        if !self.additional_packages.is_empty() {
            self.install_packages(&self.additional_packages).await?;
        }

        info!("âœ“ PackageKit plugin: Complete");
        Ok(())
    }

    async fn configure_repositories(&self) -> Result<()> {
        info!("Configuring {} repositories", self.repositories.len());

        for repo in &self.repositories {
            info!("  â†’ Adding repository: {}", repo.name);

            // Create sources.list.d entry
            let sources_entry = format!(
                "deb [arch=amd64] {} {} {}",
                repo.url,
                repo.distribution,
                repo.components.join(" ")
            );

            let sources_file = format!("/etc/apt/sources.list.d/{}.list", repo.name);
            fs::write(&sources_file, sources_entry)
                .context("Failed to write sources.list.d entry")?;

            info!("    âœ“ Created: {}", sources_file);

            // Download and install GPG key
            info!("    Downloading GPG key...");
            let response = reqwest::get(&repo.gpg_key).await?;
            let key_data = response.bytes().await?;

            let key_file = format!("/etc/apt/trusted.gpg.d/{}.gpg", repo.name);
            fs::write(&key_file, key_data)
                .context("Failed to write GPG key")?;

            info!("    âœ“ Installed GPG key: {}", key_file);
        }

        Ok(())
    }

    async fn refresh_cache(&self) -> Result<()> {
        info!("Refreshing package cache...");

        // Run apt-get update (since PackageKit doesn't always work well)
        let output = tokio::process::Command::new("apt-get")
            .arg("update")
            .output()
            .await?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            warn!("apt-get update warnings: {}", stderr);
        }

        info!("âœ“ Cache refreshed");
        Ok(())
    }

    async fn install_from_manifest(&self, manifest_path: &PathBuf) -> Result<()> {
        info!("Installing packages from manifest: {}", manifest_path.display());

        // Read manifest
        let manifest_json = fs::read_to_string(manifest_path)
            .context("Failed to read manifest")?;

        let manifest: Manifest = serde_json::from_str(&manifest_json)
            .context("Failed to parse manifest")?;

        info!("  Total packages: {}", manifest.metadata.total_packages);
        info!("  Stages: {}", manifest.metadata.stages);

        // Install each stage
        for stage in &manifest.stages {
            self.install_stage(stage).await?;
        }

        Ok(())
    }

    async fn install_stage(&self, stage: &Stage) -> Result<()> {
        info!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
        info!("STAGE: {}", stage.name.to_uppercase());
        info!("Packages: {}", stage.package_count);
        info!("Batch size: {}", stage.batch_size);
        info!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");

        // Install in batches
        for (i, chunk) in stage.packages.chunks(stage.batch_size).enumerate() {
            let batch_num = i + 1;
            let total_batches = (stage.package_count + stage.batch_size - 1) / stage.batch_size;

            info!("  ğŸ“¦ Batch {}/{} ({} packages)", batch_num, total_batches, chunk.len());

            let package_names: Vec<String> = chunk.iter()
                .map(|p| p.name.clone())
                .collect();

            // Install batch via pkcon (PackageKit CLI)
            match self.install_packages(&package_names).await {
                Ok(()) => {
                    info!("    âœ“ Batch completed");
                }
                Err(e) => {
                    warn!("    âœ— Batch failed: {}", e);

                    // Retry individual packages if batch failed
                    if stage.retry_policy == "retry_transient" || stage.retry_policy == "abort" {
                        for pkg in &package_names {
                            match self.install_packages(&[pkg.clone()]).await {
                                Ok(()) => info!("      âœ“ {}", pkg),
                                Err(_) => warn!("      âœ— {}", pkg),
                            }
                        }
                    }

                    if stage.retry_policy == "abort" && !stage.continue_on_error {
                        return Err(e);
                    }
                }
            }

            sleep(Duration::from_millis(100)).await;
        }

        info!("âœ“ Stage '{}' complete", stage.name);
        Ok(())
    }

    async fn install_packages(&self, packages: &[String]) -> Result<()> {
        if packages.is_empty() {
            return Ok(());
        }

        info!("Installing: {}", packages.join(", "));

        // Use pkcon (PackageKit CLI) for installation
        let output = tokio::process::Command::new("pkcon")
            .arg("install")
            .arg("-y")
            .args(packages)
            .output()
            .await
            .context("Failed to run pkcon")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow::anyhow!("Package installation failed: {}", stderr));
        }

        Ok(())
    }
}

// Manifest types (same as proxmox-extractor)

#[derive(Debug, Clone, Deserialize)]
struct Manifest {
    metadata: ManifestMetadata,
    stages: Vec<Stage>,
}

#[derive(Debug, Clone, Deserialize)]
struct ManifestMetadata {
    total_packages: usize,
    stages: usize,
}

#[derive(Debug, Clone, Deserialize)]
struct Stage {
    name: String,
    package_count: usize,
    batch_size: usize,
    retry_policy: String,
    continue_on_error: bool,
    packages: Vec<PackageEntry>,
}

#[derive(Debug, Clone, Deserialize)]
struct PackageEntry {
    name: String,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_plugin_config() {
        let json = r#"
        {
            "repositories": [
                {
                    "name": "pve-no-subscription",
                    "url": "http://download.proxmox.com/debian/pve",
                    "distribution": "bookworm",
                    "components": ["pve-no-subscription"],
                    "gpg_key": "https://enterprise.proxmox.com/debian/proxmox-release-bookworm.gpg"
                }
            ],
            "manifest": "/root/proxmox-ve-8-manifest.json",
            "additional_packages": ["vim", "htop"]
        }
        "#;

        let plugin: PackageKitPlugin = serde_json::from_str(json).unwrap();
        assert_eq!(plugin.repositories.len(), 1);
        assert_eq!(plugin.additional_packages.len(), 2);
    }
}
