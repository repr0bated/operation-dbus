use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use std::process;

fn main() {
    println!("cargo:rerun-if-changed=/git/agents");
    println!("cargo:rerun-if-changed=/git/commands");

    let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR not set");
    let embedded_file = Path::new(&out_dir).join("embedded_markdown.rs");

    println!("Embedding markdown files into {}", embedded_file.display());

    // Collect all markdown files
    let mut embedded_files = HashMap::new();

    // Scan agents directory
    if let Err(e) = collect_markdown_files("/git/agents", "agents", &mut embedded_files) {
        eprintln!("Warning: Could not scan agents directory: {}", e);
    }

    // Scan commands directory
    if let Err(e) = collect_markdown_files("/git/commands", "commands", &mut embedded_files) {
        eprintln!("Warning: Could not scan commands directory: {}", e);
    }

    // Generate the embedded.rs file
    generate_embedded_code(&embedded_files, &embedded_file);

    println!("Embedded {} markdown files", embedded_files.len());
}

fn collect_markdown_files(
    base_dir: &str,
    repo_name: &str,
    embedded_files: &mut HashMap<String, String>,
) -> Result<(), Box<dyn std::error::Error>> {
    let base_path = Path::new(base_dir);

    if !base_path.exists() {
        return Ok(()); // Skip if directory doesn't exist
    }

    let mut files = Vec::new();
    collect_markdown_files_recursive(base_path, Path::new(""), &mut files)?;

    for relative_path in files {
        let full_path = base_path.join(&relative_path);
        let uri = format!("{}://{}", repo_name, relative_path.display());

        // Read file content
        let content = fs::read_to_string(&full_path)
            .map_err(|e| format!("Failed to read {}: {}", full_path.display(), e))?;

        embedded_files.insert(uri, content);
    }

    Ok(())
}

fn collect_markdown_files_recursive(
    base_dir: &Path,
    current_dir: &Path,
    files: &mut Vec<PathBuf>,
) -> Result<(), Box<dyn std::error::Error>> {
    let full_current_dir = base_dir.join(current_dir);

    if !full_current_dir.exists() {
        return Ok(());
    }

    let entries = fs::read_dir(&full_current_dir)?;

    for entry in entries {
        let entry = entry?;
        let file_name = entry.file_name();
        let file_name_str = file_name.to_string_lossy();

        // Skip hidden files and directories
        if file_name_str.starts_with('.') {
            continue;
        }

        // Skip node_modules
        if file_name_str == "node_modules" {
            continue;
        }

        let metadata = entry.metadata()?;
        if metadata.is_dir() {
            let new_current_dir = current_dir.join(file_name);
            collect_markdown_files_recursive(base_dir, &new_current_dir, files)?;
        } else if metadata.is_file() && file_name_str.ends_with(".md") {
            files.push(current_dir.join(file_name));
        }
    }

    Ok(())
}

fn generate_embedded_code(embedded_files: &HashMap<String, String>, output_path: &Path) {
    let mut code = String::new();

    code.push_str("// Auto-generated embedded markdown files\n");
    code.push_str("// Do not edit manually - generated by build.rs\n\n");
    code.push_str("lazy_static::lazy_static! {\n");
    code.push_str("    pub static ref EMBEDDED_MARKDOWN: HashMap<&'static str, &'static str> = {\n");
    code.push_str("        let mut m = HashMap::new();\n");

    for (uri, content) in embedded_files {
        // Use a more robust escaping approach
        let escaped_content = escape_string_for_rust(content);

        code.push_str(&format!("        m.insert(\"{}\", \"{}\");\n", uri, escaped_content));
    }

    code.push_str("        m\n");
    code.push_str("    };\n");
    code.push_str("}\n\n");

    // Generate a function to get content by URI
    code.push_str("/// Get embedded markdown content by URI\n");
    code.push_str("pub fn get_embedded_markdown(uri: &str) -> Option<&'static str> {\n");
    code.push_str("    EMBEDDED_MARKDOWN.get(uri).copied()\n");
    code.push_str("}\n\n");

    // Generate a function to list all URIs
    code.push_str("/// Get all embedded markdown URIs\n");
    code.push_str("pub fn get_embedded_markdown_uris() -> Vec<&'static str> {\n");
    code.push_str("    EMBEDDED_MARKDOWN.keys().copied().collect()\n");
    code.push_str("}\n");

    if let Err(e) = fs::write(output_path, code) {
        eprintln!("Failed to write embedded file {}: {}", output_path.display(), e);
        process::exit(1);
    }
}

fn escape_string_for_rust(input: &str) -> String {
    let mut result = String::with_capacity(input.len() + input.len() / 4);

    for ch in input.chars() {
        match ch {
            '"' => result.push_str("\\\""),
            '\\' => result.push_str("\\\\"),
            '\n' => result.push_str("\\n"),
            '\r' => result.push_str("\\r"),
            '\t' => result.push_str("\\t"),
            '\0' => result.push_str("\\0"),
            ch if ch.is_control() => {
                result.push_str(&format!("\\u{{{:04x}}}", ch as u32));
            }
            ch => result.push(ch),
        }
    }

    result
}