# Auto-Plugin Integration Plan

## Problem Statement

We have **two separate D-Bus discovery systems** that don't talk to each other:

1. **`src/state/auto_plugin.rs`** - Runtime plugin generation (already exists)
   - Discovers D-Bus services
   - Creates plugins without compilation
   - Can read state
   - **Cannot write** state (read-only)

2. **`src/introspection/mod.rs`** - System introspection (just built)
   - Discovers D-Bus services (duplicates auto_plugin!)
   - Reports for `op-dbus discover` command
   - Doesn't create plugins
   - Just for reporting/replication

## Current Architecture (Broken)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       StateManager (runtime)           â”‚
â”‚                                        â”‚
â”‚  Uses: auto_plugin.rs                  â”‚
â”‚  â”œâ”€ AutoGeneratedPlugin (PackageKit)  â”‚ â† Read-only
â”‚  â””â”€ AutoGeneratedPlugin (NetworkMgr)  â”‚ â† Read-only
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    op-dbus discover (CLI command)      â”‚
â”‚                                        â”‚
â”‚  Uses: introspection/mod.rs            â”‚
â”‚  â”œâ”€ Discovers same services AGAIN     â”‚ â† Duplication!
â”‚  â””â”€ Reports them as "unmanaged"       â”‚ â† Wrong!
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Proposed Architecture (Fixed)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Unified Discovery Engine           â”‚
â”‚     (src/state/auto_plugin.rs)         â”‚
â”‚                                        â”‚
â”‚  discover_services() â†’ [PackageKit,...]â”‚
â”‚  introspect_service() â†’ IntrospectionData
â”‚  create_plugin() â†’ AutoGeneratedPluginâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â–²          â–²
              â”‚          â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                â”‚
â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   StateManager      â”‚   â”‚  op-dbus discover      â”‚
â”‚   (runtime)         â”‚   â”‚  (CLI command)         â”‚
â”‚                     â”‚   â”‚                        â”‚
â”‚  Uses auto-plugins  â”‚   â”‚  Reports using         â”‚
â”‚  for state mgmt     â”‚   â”‚  introspection data    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Integration Steps

### Step 1: Share Discovery Logic

**Current** (duplicated):
- `auto_plugin.rs`: `PluginDiscovery::discover_services()`
- `introspection/mod.rs`: `discover_dbus_services()`

**Fixed** (shared):
```rust
// introspection/mod.rs uses auto_plugin.rs
use crate::state::auto_plugin::PluginDiscovery;

async fn discover_dbus_services(&self) -> Result<(Vec<String>, Vec<String>)> {
    // Reuse existing discovery!
    let system_services = PluginDiscovery::discover_services().await?;

    let session_services = match Connection::session().await {
        Ok(conn) => { /* discover session services */ },
        Err(_) => Vec::new(),
    };

    Ok((system_services, session_services))
}
```

### Step 2: Integrate with StateManager

When `op-dbus discover` runs, it should query the **active StateManager** to see which plugins are already loaded:

```rust
// introspection/mod.rs
pub async fn introspect_with_state_manager(
    &self,
    state_manager: Option<&StateManager>,
) -> Result<IntrospectionReport> {
    let (system_services, session_services) = self.discover_dbus_services().await?;

    // Check which services are already managed
    let managed_services = if let Some(sm) = state_manager {
        sm.list_active_plugins()  // Returns ["systemd", "login1", "packagekit", ...]
    } else {
        Vec::new()
    };

    // Categorize services
    let (managed, unmanaged) = self.categorize_with_active_plugins(
        system_services,
        session_services,
        &managed_services,
    );

    // Now PackageKit shows as "managed" if auto-plugin exists!
}
```

### Step 3: Report Auto-Generated Plugins Correctly

**Current output** (wrong):
```
ðŸ” UNMANAGED D-BUS SERVICES
  âŠ— org.freedesktop.PackageKit (system)
    Reason: No plugin available
```

**Fixed output** (correct):
```
âœ… MANAGED D-BUS SERVICES
  âœ“ org.freedesktop.PackageKit (system)
    Auto-generated plugin (read-only)

âš ï¸  Note: Auto-generated plugins can query state but cannot apply changes.
    To enable management, create a dedicated plugin.
```

### Step 4: Enable Auto-Plugin Creation on Demand

Add CLI command to enable auto-plugins:

```bash
# Discover and create auto-plugins for all services
sudo op-dbus discover --auto-enable

# Output:
# ðŸ” Discovering D-Bus services...
#   âœ“ Found 23 services
#
# ðŸ¤– Creating auto-generated plugins...
#   âœ“ Created: packagekit (read-only)
#   âœ“ Created: networkmanager (read-only)
#   âœ“ Created: upower (read-only)
#   ...
#
# âš ï¸  These plugins are read-only. To enable writes, add semantic mappings.
```

## Making Auto-Plugins Writable (Advanced)

The challenge: we can't blindly call D-Bus methods without understanding semantics.

### Option 1: Semantic Mapping File

Create a mapping file that teaches op-dbus how to manage services:

**File**: `semantic-mappings/packagekit.toml`
```toml
service = "org.freedesktop.PackageKit"

[state_mapping]
# Map declarative state to D-Bus methods
"packages" = { method = "InstallPackages", property = "installed_packages" }
"repositories" = { method = "RepoSetData", property = "repo_list" }

[methods]
# Safe methods (read-only)
GetPackages = { safe = true, side_effects = false }
GetUpdates = { safe = true, side_effects = false }

# Unsafe methods (modify system)
InstallPackages = { safe = false, side_effects = true, requires_confirmation = true }
RemovePackages = { safe = false, side_effects = true, requires_confirmation = true }

[property_setters]
# How to set properties
"RefreshCache" = { method = "RefreshCache", args = [] }
```

Then:
```rust
// auto_plugin.rs
impl AutoGeneratedPlugin {
    async fn apply_state(&self, diff: &StateDiff) -> Result<ApplyResult> {
        // Load semantic mapping if available
        if let Some(mapping) = SemanticMapping::load(&self.service_name)? {
            // Now we can safely apply changes!
            return self.apply_with_mapping(diff, &mapping).await;
        }

        // Fallback: read-only
        Ok(ApplyResult {
            success: false,
            errors: vec![format!(
                "No semantic mapping for '{}'. Plugin is read-only.",
                self.name
            )],
            checkpoint: None,
        })
    }
}
```

### Option 2: Heuristic Method Calling (Conservative)

Auto-detect safe patterns:

```rust
impl AutoGeneratedPlugin {
    async fn apply_state(&self, diff: &StateDiff) -> Result<ApplyResult> {
        for action in &diff.actions {
            match action {
                StateAction::Modify { resource, changes } => {
                    // Look for property setters
                    for (prop_name, new_value) in changes.as_object().unwrap() {
                        // Try to find a Set<PropertyName> method
                        let setter_name = format!("Set{}", prop_name);

                        if let Some(method) = self.find_method(&setter_name) {
                            // Found a setter! Call it
                            self.call_method(&setter_name, vec![new_value]).await?;
                        } else {
                            // No setter found, try org.freedesktop.DBus.Properties
                            self.set_property(prop_name, new_value).await?;
                        }
                    }
                }
                _ => {}
            }
        }

        Ok(ApplyResult { success: true, /* ... */ })
    }
}
```

### Option 3: Interactive Mode (Safest)

Ask the user before calling methods:

```rust
async fn apply_state(&self, diff: &StateDiff) -> Result<ApplyResult> {
    for action in &diff.actions {
        // Show user what will happen
        println!("About to call D-Bus method:");
        println!("  Service: {}", self.service_name);
        println!("  Method: InstallPackages");
        println!("  Args: {:?}", args);
        println!("\n  Proceed? [y/N]: ");

        let mut input = String::new();
        std::io::stdin().read_line(&mut input)?;

        if input.trim().to_lowercase() != "y" {
            return Ok(ApplyResult {
                success: false,
                errors: vec!["User cancelled operation".to_string()],
                checkpoint: None,
            });
        }

        // User approved, call method
        self.call_method("InstallPackages", args).await?;
    }
}
```

## Implementation Plan

### Phase 1: Integration (Week 1)
- [ ] Make introspection use auto_plugin discovery
- [ ] Report auto-generated plugins as "managed (read-only)"
- [ ] Add `--auto-enable` flag to create auto-plugins
- [ ] Document which services have auto-plugins

### Phase 2: Semantic Mappings (Week 2-3)
- [ ] Design semantic mapping format (TOML/JSON)
- [ ] Implement mapping loader
- [ ] Create mappings for common services:
  - [ ] PackageKit (package management)
  - [ ] NetworkManager (network config)
  - [ ] UPower (power management)
  - [ ] UDisks2 (disk management)

### Phase 3: Writable Auto-Plugins (Week 4)
- [ ] Implement apply_with_mapping()
- [ ] Add safety checks (dry-run mode)
- [ ] Test with PackageKit
- [ ] Document how to create semantic mappings

### Phase 4: Community Mappings (Ongoing)
- [ ] Create repository: op-dbus-semantic-mappings
- [ ] Allow users to contribute mappings
- [ ] Build library of mappings for common services
- [ ] Auto-download mappings from repo

## Example: PackageKit with Semantic Mapping

**Before** (read-only):
```json
{
  "plugins": {
    "packagekit": {
      "packages": ["nginx", "postgres"]
    }
  }
}
```

```bash
sudo op-dbus apply state.json
# Error: Auto-generated plugin 'packagekit' is read-only
```

**After** (with semantic mapping):
```bash
sudo op-dbus apply state.json
# âœ“ Loading semantic mapping for org.freedesktop.PackageKit
# âœ“ Calling InstallPackages(["nginx", "postgres"])
# âœ“ Applied changes successfully
```

## Benefits

1. **Immediate Value**: Auto-plugins for read-only state capture (introspection)
2. **Progressive Enhancement**: Add semantic mappings as needed
3. **Community Driven**: Users contribute mappings for their services
4. **Safe by Default**: Read-only unless explicitly mapped
5. **No Compilation**: Everything happens at runtime

## Next Steps

1. Integrate introspection with auto_plugin
2. Test on your laptop (see PackageKit as "managed (read-only)")
3. Decide if we want semantic mappings (Phase 2)
4. If yes, create PackageKit mapping as proof of concept

---

**This turns op-dbus into a truly dynamic system where ANY D-Bus service can be managed without writing code.**
